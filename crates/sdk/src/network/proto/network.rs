// This file is @generated by prost-build.
/// The request to create a proof, the first step in requesting a proof.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The mode for proof generation.
    #[prost(enumeration = "ProofMode", tag = "3")]
    pub mode: i32,
    /// The deadline for the proof request, signifying the latest time a fulfillment would be valid.
    #[prost(uint64, tag = "4")]
    pub deadline: u64,
    /// The SP1 circuit version to use for the proof.
    #[prost(string, tag = "5")]
    pub circuit_version: ::prost::alloc::string::String,
}
/// The response for creating a proof.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateProofResponse {
    /// The proof identifier.
    #[prost(string, tag = "1")]
    pub proof_id: ::prost::alloc::string::String,
    /// The URL to upload the ELF file.
    #[prost(string, tag = "2")]
    pub program_url: ::prost::alloc::string::String,
    /// The URL to upload the standard input (stdin).
    #[prost(string, tag = "3")]
    pub stdin_url: ::prost::alloc::string::String,
}
/// The request to submit a proof, the second step in requesting a proof. MUST be called when the
/// proof is in a PROOF_REQUESTED state and MUST be called after uploading the program and stdin to
/// the URLs provided during create proof.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct SubmitProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
}
/// The response for submitting a proof, empty on success.
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitProofResponse {}
/// The request to claim a proof, which agrees to fulfill the proof by the deadline. MUST be called
/// when the proof is in a PROOF_REQUESTED state.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClaimProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
}
/// The response for claiming a proof, giving identifiers for the locations to retrieve the program
/// and stdin, as well as the location to upload the proof.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ClaimProofResponse {
    /// The artifact identifier for the program location.
    #[prost(string, tag = "1")]
    pub program_artifact_id: ::prost::alloc::string::String,
    /// The artifact identifier for the stdin location.
    #[prost(string, tag = "2")]
    pub stdin_artifact_id: ::prost::alloc::string::String,
    /// The artifact identifier for the proof location.
    #[prost(string, tag = "3")]
    pub proof_artifact_id: ::prost::alloc::string::String,
}
/// The request to unclaim a proof, which cancels the claim to fulfill the proof. MUST be called
/// when the proof is in a PROOF_CLAIMED state and MUST be called by the prover who claimed it.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct UnclaimProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
    /// The reason for unclaiming the proof.
    #[prost(enumeration = "UnclaimReason", tag = "4")]
    pub reason: i32,
    /// The description for the reason.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
}
/// The response for unclaiming a proof, empty on success.
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnclaimProofResponse {}
/// The request to update a proof's CPU cycle count.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ModifyCpuCyclesRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
    /// The number of CPU cycles for this proof.
    #[prost(uint64, tag = "4")]
    pub cycles: u64,
}
/// The response for updating a proof's CPU cycle count, empty on success.
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModifyCpuCyclesResponse {}
/// The request to fulfill a proof. MUST be called after the proof has been uploaded and MUST be called
/// when the proof is in a PROOF_CLAIMED state.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FulfillProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
}
/// The response for fulfilling a proof, empty on success.
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillProofResponse {
    /// The amount of time, in seconds, between proof claim and fulfillment.
    #[prost(uint64, tag = "1")]
    pub proving_seconds: u64,
}
/// The request to relay a proof through the NetworkGateway on a given chain. MUST be called when the
/// proof is in a PROOF_FULFILLED state.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RelayProofRequest {
    /// The signature of the message.
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// The nonce for the account.
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
    /// The proof identifier.
    #[prost(string, tag = "3")]
    pub proof_id: ::prost::alloc::string::String,
    /// The chain ID for the requested chain.
    #[prost(uint32, tag = "4")]
    pub chain_id: u32,
    /// The address of the verifier for this proof.
    #[prost(bytes = "vec", tag = "5")]
    pub verifier: ::prost::alloc::vec::Vec<u8>,
    /// The address of the callback to call after the proof has been verified by the verifier.
    #[prost(bytes = "vec", tag = "6")]
    pub callback: ::prost::alloc::vec::Vec<u8>,
    /// The data to send to the callback, including the function selector.
    #[prost(bytes = "vec", tag = "7")]
    pub callback_data: ::prost::alloc::vec::Vec<u8>,
}
/// The response for relaying a proof.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RelayProofResponse {
    /// The transaction identifier.
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
}
/// The request for an account nonce. Used to check current nonce for the account, which must match when signing and sending a message.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetNonceRequest {
    /// The account's address for which to get the nonce.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
/// The response for a nonce request.
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetNonceResponse {
    /// The nonce for the given address. It should be signed along with the rest of the message.
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
/// The request to get a proof status by a given proof ID.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofStatusRequest {
    /// The proof identifier.
    #[prost(string, tag = "1")]
    pub proof_id: ::prost::alloc::string::String,
}
/// The response for a proof status request.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofStatusResponse {
    /// The status of the proof request.
    #[prost(enumeration = "ProofStatus", tag = "1")]
    pub status: i32,
    /// Optional proof URL, where you can download the result of the proof request. Only included if
    /// the proof has been fulfilled.
    #[prost(string, optional, tag = "2")]
    pub proof_url: ::core::option::Option<::prost::alloc::string::String>,
    /// If the proof was unclaimed, the reason why.
    #[prost(enumeration = "UnclaimReason", optional, tag = "3")]
    pub unclaim_reason: ::core::option::Option<i32>,
    /// If the proof was unclaimed, the description detailing why.
    #[prost(string, optional, tag = "4")]
    pub unclaim_description: ::core::option::Option<::prost::alloc::string::String>,
}
/// The request to get proof requests by a given status.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestsRequest {
    /// The status of the proof requests to filter for.
    #[prost(enumeration = "ProofStatus", tag = "1")]
    pub status: i32,
    /// The SP1 circuit version of the proof requests to filter for.
    #[prost(string, optional, tag = "2")]
    pub circuit_version: ::core::option::Option<::prost::alloc::string::String>,
}
/// A proof request.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RequestedProof {
    /// The proof identifier.
    #[prost(string, tag = "1")]
    pub proof_id: ::prost::alloc::string::String,
    /// The mode for proof generation.
    #[prost(enumeration = "ProofMode", tag = "2")]
    pub mode: i32,
    /// Proof requester's address.
    #[prost(bytes = "vec", tag = "3")]
    pub requester: ::prost::alloc::vec::Vec<u8>,
    /// The SP1 circuit version to use for the proof.
    #[prost(string, tag = "4")]
    pub circuit_version: ::prost::alloc::string::String,
}
/// The response for getting proof requests by a given status.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetProofRequestsResponse {
    /// The proof identifiers of the proof requests. Limited to the 10 most recent proof requests with
    /// that status.
    #[prost(message, repeated, tag = "1")]
    pub proofs: ::prost::alloc::vec::Vec<RequestedProof>,
}
/// The request to get the status of a relay request.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetRelayStatusRequest {
    /// The transaction identifier.
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
}
/// The response for getting the status of a relay request.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetRelayStatusResponse {
    /// The status of the transaction.
    #[prost(enumeration = "TransactionStatus", tag = "1")]
    pub status: i32,
    /// The transaction hash.
    #[prost(bytes = "vec", tag = "2")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// The transactionsimulation URL, only present if the transaction failed.
    #[prost(string, tag = "3")]
    pub simulation_url: ::prost::alloc::string::String,
}
/// The mode used when generating the proof.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofMode {
    /// Unspecified or invalid proof mode.
    Unspecified = 0,
    /// The proof mode for an SP1 core proof.
    Core = 1,
    /// The proof mode for a compressed proof.
    Compressed = 2,
    /// The proof mode for a PlonK proof.
    Plonk = 3,
    /// The proof mode for a Groth16 proof.
    Groth16 = 4,
}
impl ProofMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROOF_MODE_UNSPECIFIED",
            Self::Core => "PROOF_MODE_CORE",
            Self::Compressed => "PROOF_MODE_COMPRESSED",
            Self::Plonk => "PROOF_MODE_PLONK",
            Self::Groth16 => "PROOF_MODE_GROTH16",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROOF_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROOF_MODE_CORE" => Some(Self::Core),
            "PROOF_MODE_COMPRESSED" => Some(Self::Compressed),
            "PROOF_MODE_PLONK" => Some(Self::Plonk),
            "PROOF_MODE_GROTH16" => Some(Self::Groth16),
            _ => None,
        }
    }
}
/// The status of a proof request.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProofStatus {
    /// Unspecified or invalid status.
    ProofUnspecifiedStatus = 0,
    /// The proof request has been created but is awaiting the requester to submit it.
    ProofPreparing = 1,
    /// The proof request has been submitted and is awaiting a prover to claim it.
    ProofRequested = 2,
    /// The proof request has been claimed and is awaiting a prover to fulfill it.
    ProofClaimed = 3,
    /// The proof request was previously claimed but has now been unclaimed.
    ProofUnclaimed = 4,
    /// The proof request has been fulfilled and is available for download.
    ProofFulfilled = 5,
}
impl ProofStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ProofUnspecifiedStatus => "PROOF_UNSPECIFIED_STATUS",
            Self::ProofPreparing => "PROOF_PREPARING",
            Self::ProofRequested => "PROOF_REQUESTED",
            Self::ProofClaimed => "PROOF_CLAIMED",
            Self::ProofUnclaimed => "PROOF_UNCLAIMED",
            Self::ProofFulfilled => "PROOF_FULFILLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROOF_UNSPECIFIED_STATUS" => Some(Self::ProofUnspecifiedStatus),
            "PROOF_PREPARING" => Some(Self::ProofPreparing),
            "PROOF_REQUESTED" => Some(Self::ProofRequested),
            "PROOF_CLAIMED" => Some(Self::ProofClaimed),
            "PROOF_UNCLAIMED" => Some(Self::ProofUnclaimed),
            "PROOF_FULFILLED" => Some(Self::ProofFulfilled),
            _ => None,
        }
    }
}
/// The status of a relay request transaction.
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum TransactionStatus {
    /// Unspecified or invalid status.
    TransactionUnspecifiedStatus = 0,
    /// The transaction has been scheduled for relay.
    TransactionScheduled = 1,
    /// The transaction has been broadcast to the requested chain.
    TransactionBroadcasted = 2,
    /// The transaction was never confirmed as mined.
    TransactionTimedout = 3,
    /// The transaction failed to be broadcast, likely due to a revert in simulation.
    TransactionFailed = 4,
    /// The transaction was mined successfully.
    TransactionFinalized = 5,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TransactionUnspecifiedStatus => "TRANSACTION_UNSPECIFIED_STATUS",
            Self::TransactionScheduled => "TRANSACTION_SCHEDULED",
            Self::TransactionBroadcasted => "TRANSACTION_BROADCASTED",
            Self::TransactionTimedout => "TRANSACTION_TIMEDOUT",
            Self::TransactionFailed => "TRANSACTION_FAILED",
            Self::TransactionFinalized => "TRANSACTION_FINALIZED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_UNSPECIFIED_STATUS" => Some(Self::TransactionUnspecifiedStatus),
            "TRANSACTION_SCHEDULED" => Some(Self::TransactionScheduled),
            "TRANSACTION_BROADCASTED" => Some(Self::TransactionBroadcasted),
            "TRANSACTION_TIMEDOUT" => Some(Self::TransactionTimedout),
            "TRANSACTION_FAILED" => Some(Self::TransactionFailed),
            "TRANSACTION_FINALIZED" => Some(Self::TransactionFinalized),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum UnclaimReason {
    /// Unspecified reason.
    Unspecified = 0,
    /// The prover claims the request is invalid and cannot be fulfilled.
    Invalid = 1,
    /// The prover is unable to fulfill the proof due to any other reason.
    Abandoned = 2,
}
impl UnclaimReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNCLAIM_REASON_UNSPECIFIED",
            Self::Invalid => "UNCLAIM_REASON_INVALID",
            Self::Abandoned => "UNCLAIM_REASON_ABANDONED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNCLAIM_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "UNCLAIM_REASON_INVALID" => Some(Self::Invalid),
            "UNCLAIM_REASON_ABANDONED" => Some(Self::Abandoned),
            _ => None,
        }
    }
}
pub use twirp;
pub const SERVICE_FQN: &str = "/network.NetworkService";
#[twirp::async_trait::async_trait]
pub trait NetworkService {
    async fn create_proof(
        &self,
        ctx: twirp::Context,
        req: CreateProofRequest,
    ) -> Result<CreateProofResponse, twirp::TwirpErrorResponse>;
    async fn submit_proof(
        &self,
        ctx: twirp::Context,
        req: SubmitProofRequest,
    ) -> Result<SubmitProofResponse, twirp::TwirpErrorResponse>;
    async fn claim_proof(
        &self,
        ctx: twirp::Context,
        req: ClaimProofRequest,
    ) -> Result<ClaimProofResponse, twirp::TwirpErrorResponse>;
    async fn unclaim_proof(
        &self,
        ctx: twirp::Context,
        req: UnclaimProofRequest,
    ) -> Result<UnclaimProofResponse, twirp::TwirpErrorResponse>;
    async fn modify_cpu_cycles(
        &self,
        ctx: twirp::Context,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::TwirpErrorResponse>;
    async fn fulfill_proof(
        &self,
        ctx: twirp::Context,
        req: FulfillProofRequest,
    ) -> Result<FulfillProofResponse, twirp::TwirpErrorResponse>;
    async fn relay_proof(
        &self,
        ctx: twirp::Context,
        req: RelayProofRequest,
    ) -> Result<RelayProofResponse, twirp::TwirpErrorResponse>;
    async fn get_nonce(
        &self,
        ctx: twirp::Context,
        req: GetNonceRequest,
    ) -> Result<GetNonceResponse, twirp::TwirpErrorResponse>;
    async fn get_proof_status(
        &self,
        ctx: twirp::Context,
        req: GetProofStatusRequest,
    ) -> Result<GetProofStatusResponse, twirp::TwirpErrorResponse>;
    async fn get_proof_requests(
        &self,
        ctx: twirp::Context,
        req: GetProofRequestsRequest,
    ) -> Result<GetProofRequestsResponse, twirp::TwirpErrorResponse>;
    async fn get_relay_status(
        &self,
        ctx: twirp::Context,
        req: GetRelayStatusRequest,
    ) -> Result<GetRelayStatusResponse, twirp::TwirpErrorResponse>;
}
#[twirp::async_trait::async_trait]
impl<T> NetworkService for std::sync::Arc<T>
where
    T: NetworkService + Sync + Send,
{
    async fn create_proof(
        &self,
        ctx: twirp::Context,
        req: CreateProofRequest,
    ) -> Result<CreateProofResponse, twirp::TwirpErrorResponse> {
        T::create_proof(&*self, ctx, req).await
    }
    async fn submit_proof(
        &self,
        ctx: twirp::Context,
        req: SubmitProofRequest,
    ) -> Result<SubmitProofResponse, twirp::TwirpErrorResponse> {
        T::submit_proof(&*self, ctx, req).await
    }
    async fn claim_proof(
        &self,
        ctx: twirp::Context,
        req: ClaimProofRequest,
    ) -> Result<ClaimProofResponse, twirp::TwirpErrorResponse> {
        T::claim_proof(&*self, ctx, req).await
    }
    async fn unclaim_proof(
        &self,
        ctx: twirp::Context,
        req: UnclaimProofRequest,
    ) -> Result<UnclaimProofResponse, twirp::TwirpErrorResponse> {
        T::unclaim_proof(&*self, ctx, req).await
    }
    async fn modify_cpu_cycles(
        &self,
        ctx: twirp::Context,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::TwirpErrorResponse> {
        T::modify_cpu_cycles(&*self, ctx, req).await
    }
    async fn fulfill_proof(
        &self,
        ctx: twirp::Context,
        req: FulfillProofRequest,
    ) -> Result<FulfillProofResponse, twirp::TwirpErrorResponse> {
        T::fulfill_proof(&*self, ctx, req).await
    }
    async fn relay_proof(
        &self,
        ctx: twirp::Context,
        req: RelayProofRequest,
    ) -> Result<RelayProofResponse, twirp::TwirpErrorResponse> {
        T::relay_proof(&*self, ctx, req).await
    }
    async fn get_nonce(
        &self,
        ctx: twirp::Context,
        req: GetNonceRequest,
    ) -> Result<GetNonceResponse, twirp::TwirpErrorResponse> {
        T::get_nonce(&*self, ctx, req).await
    }
    async fn get_proof_status(
        &self,
        ctx: twirp::Context,
        req: GetProofStatusRequest,
    ) -> Result<GetProofStatusResponse, twirp::TwirpErrorResponse> {
        T::get_proof_status(&*self, ctx, req).await
    }
    async fn get_proof_requests(
        &self,
        ctx: twirp::Context,
        req: GetProofRequestsRequest,
    ) -> Result<GetProofRequestsResponse, twirp::TwirpErrorResponse> {
        T::get_proof_requests(&*self, ctx, req).await
    }
    async fn get_relay_status(
        &self,
        ctx: twirp::Context,
        req: GetRelayStatusRequest,
    ) -> Result<GetRelayStatusResponse, twirp::TwirpErrorResponse> {
        T::get_relay_status(&*self, ctx, req).await
    }
}
pub fn router<T>(api: T) -> twirp::Router
where
    T: NetworkService + Clone + Send + Sync + 'static,
{
    twirp::details::TwirpRouterBuilder::new(api)
        .route("/CreateProof", |api: T, ctx: twirp::Context, req: CreateProofRequest| async move {
            api.create_proof(ctx, req).await
        })
        .route("/SubmitProof", |api: T, ctx: twirp::Context, req: SubmitProofRequest| async move {
            api.submit_proof(ctx, req).await
        })
        .route("/ClaimProof", |api: T, ctx: twirp::Context, req: ClaimProofRequest| async move {
            api.claim_proof(ctx, req).await
        })
        .route(
            "/UnclaimProof",
            |api: T, ctx: twirp::Context, req: UnclaimProofRequest| async move {
                api.unclaim_proof(ctx, req).await
            },
        )
        .route(
            "/ModifyCpuCycles",
            |api: T, ctx: twirp::Context, req: ModifyCpuCyclesRequest| async move {
                api.modify_cpu_cycles(ctx, req).await
            },
        )
        .route(
            "/FulfillProof",
            |api: T, ctx: twirp::Context, req: FulfillProofRequest| async move {
                api.fulfill_proof(ctx, req).await
            },
        )
        .route("/RelayProof", |api: T, ctx: twirp::Context, req: RelayProofRequest| async move {
            api.relay_proof(ctx, req).await
        })
        .route("/GetNonce", |api: T, ctx: twirp::Context, req: GetNonceRequest| async move {
            api.get_nonce(ctx, req).await
        })
        .route(
            "/GetProofStatus",
            |api: T, ctx: twirp::Context, req: GetProofStatusRequest| async move {
                api.get_proof_status(ctx, req).await
            },
        )
        .route(
            "/GetProofRequests",
            |api: T, ctx: twirp::Context, req: GetProofRequestsRequest| async move {
                api.get_proof_requests(ctx, req).await
            },
        )
        .route(
            "/GetRelayStatus",
            |api: T, ctx: twirp::Context, req: GetRelayStatusRequest| async move {
                api.get_relay_status(ctx, req).await
            },
        )
        .build()
}
#[twirp::async_trait::async_trait]
pub trait NetworkServiceClient: Send + Sync + std::fmt::Debug {
    async fn create_proof(
        &self,
        req: CreateProofRequest,
    ) -> Result<CreateProofResponse, twirp::ClientError>;
    async fn submit_proof(
        &self,
        req: SubmitProofRequest,
    ) -> Result<SubmitProofResponse, twirp::ClientError>;
    async fn claim_proof(
        &self,
        req: ClaimProofRequest,
    ) -> Result<ClaimProofResponse, twirp::ClientError>;
    async fn unclaim_proof(
        &self,
        req: UnclaimProofRequest,
    ) -> Result<UnclaimProofResponse, twirp::ClientError>;
    async fn modify_cpu_cycles(
        &self,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::ClientError>;
    async fn fulfill_proof(
        &self,
        req: FulfillProofRequest,
    ) -> Result<FulfillProofResponse, twirp::ClientError>;
    async fn relay_proof(
        &self,
        req: RelayProofRequest,
    ) -> Result<RelayProofResponse, twirp::ClientError>;
    async fn get_nonce(&self, req: GetNonceRequest)
        -> Result<GetNonceResponse, twirp::ClientError>;
    async fn get_proof_status(
        &self,
        req: GetProofStatusRequest,
    ) -> Result<GetProofStatusResponse, twirp::ClientError>;
    async fn get_proof_requests(
        &self,
        req: GetProofRequestsRequest,
    ) -> Result<GetProofRequestsResponse, twirp::ClientError>;
    async fn get_relay_status(
        &self,
        req: GetRelayStatusRequest,
    ) -> Result<GetRelayStatusResponse, twirp::ClientError>;
}
#[twirp::async_trait::async_trait]
impl NetworkServiceClient for twirp::client::Client {
    async fn create_proof(
        &self,
        req: CreateProofRequest,
    ) -> Result<CreateProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/CreateProof", req).await
    }
    async fn submit_proof(
        &self,
        req: SubmitProofRequest,
    ) -> Result<SubmitProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/SubmitProof", req).await
    }
    async fn claim_proof(
        &self,
        req: ClaimProofRequest,
    ) -> Result<ClaimProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/ClaimProof", req).await
    }
    async fn unclaim_proof(
        &self,
        req: UnclaimProofRequest,
    ) -> Result<UnclaimProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/UnclaimProof", req).await
    }
    async fn modify_cpu_cycles(
        &self,
        req: ModifyCpuCyclesRequest,
    ) -> Result<ModifyCpuCyclesResponse, twirp::ClientError> {
        self.request("network.NetworkService/ModifyCpuCycles", req).await
    }
    async fn fulfill_proof(
        &self,
        req: FulfillProofRequest,
    ) -> Result<FulfillProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/FulfillProof", req).await
    }
    async fn relay_proof(
        &self,
        req: RelayProofRequest,
    ) -> Result<RelayProofResponse, twirp::ClientError> {
        self.request("network.NetworkService/RelayProof", req).await
    }
    async fn get_nonce(
        &self,
        req: GetNonceRequest,
    ) -> Result<GetNonceResponse, twirp::ClientError> {
        self.request("network.NetworkService/GetNonce", req).await
    }
    async fn get_proof_status(
        &self,
        req: GetProofStatusRequest,
    ) -> Result<GetProofStatusResponse, twirp::ClientError> {
        self.request("network.NetworkService/GetProofStatus", req).await
    }
    async fn get_proof_requests(
        &self,
        req: GetProofRequestsRequest,
    ) -> Result<GetProofRequestsResponse, twirp::ClientError> {
        self.request("network.NetworkService/GetProofRequests", req).await
    }
    async fn get_relay_status(
        &self,
        req: GetRelayStatusRequest,
    ) -> Result<GetRelayStatusResponse, twirp::ClientError> {
        self.request("network.NetworkService/GetRelayStatus", req).await
    }
}
